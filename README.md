# Отчет по многопоточному приложению: Задача о больнице (вариант 15)

## Введение

В данном отчете представлен анализ разработанных многопоточных приложений, моделирующих рабочий день клиники. Программа симулирует взаимодействие пациентов, дежурных врачей и специалистов (стоматолог, хирург, терапевт).

## Критерии и подтверждения их выполнения

### Общие требования

1. **Корректная реализация взаимодействия потоков:**
   - Программы корректно реализуют взаимодействие между потоками пациентов, дежурных врачей и специалистов. Используются мьютексы и условные переменные для синхронизации доступа к общим ресурсам (очередям) и предотвращения гонок данных.

2. **Использование языка C/C++ с POSIX Threads:**
   - Первая и вторая версия программы реализованы на языке C++ с использованием POSIX Threads (`pthread`), без использования более высокоуровневых библиотек для многопоточности. Третья версия использует OpenMP, что соответствует требованиям для максимальной оценки.

### Критерии на 4–5 баллов

1. **Соблюдены общие требования к отчету:**
   - Данный отчет структурирован согласно заданию.

2. **Описание сценария:**
   - В больнице есть 2 дежурных врача и 3 специалиста (стоматолог, хирург, терапевт). В больницу приходят пациенты, которые встают в очередь к дежурным врачам, которые принимают их по мере освобождения. Каждого принятого пациента дежурный врач отправляет к одному из специалистов (сейчас этот выбор осуществлен случайным образом). К каждому специалисту также есть очередь, в которую попадают направленные к нему пациенты. Он принимает их по мере освобождения. Когда все пациенты приняты, дежурные врачи завершают свой рабочий день и уходят домой. Если все пациенты были приняты дежурными врачами и направлены в нужным специалистом, и при этом очередь какого-то специалиста пуста (то есть в рамках этого рабочего дня к нему больше не попадет пациент), он завершает свой рабочий день и уходит домой. Пациент считается вылеченным и после этого уходит домой, когда он посетил специалиста, к которому его направил дежурный врач.

3. **Описание модели параллельных вычислений:**
   - Используется модель "Производители и потребители". Получается своего рода конвейер:
      * Сначала пациенты "производят", когда встают в очередь.
      * Затем дежурные доктора "потребляют", когда принимают пациентов.
      * Затем они же "производят" направляя пациента к одному из специалистов.
      * Специалисты "потребляют", принимая направленных к ним пациентов.

4. **Описание входных данных:**
   - Вхоными параметрами программы являются количество пациентов, время приема дежурного врача и специалиста, а также имя файла для логирования. Время и количество должны быть положительными числами, ограничения сверху нет, но логично, что если поставить слишком много, то программа будет выполняться очень долго.

5. **Реализация консольного приложения с синхропримитивами:**
   - Программы являются консольными приложениями, первая из программ, например, использует мьютексы и условные переменные для синхронизации потоков.

6. **Ввод данных с консоли во время выполнения:**
   - Противоречит критерию на более высокий балл, где просят сделать ввод через аргументы в командной строке, что я и сделал. Также есть возможность ввода данных через конфигурационный файл.

7. **Описание генераторов случайных чисел:**
   - Используется генератор `std::mt19937` с фиксированным сидом (чтобы можно было сравнивать программы) для выбора специалиста, к которому направляет пациента дежурный врач. Диапазон генератора определен как [0, 2], соответствующий типам специалистов: стоматолог(0), хирург(1), терапевт(2).

8. **Информативный вывод программы:**
   - Все ключевые события (присоединение пациентов к очереди, прием пациентов врачами, направление к специалистам, лечение, завершение рабочего дня) логируются как в консоль, так и в файл, что позволяет наблюдателю понимать происходящие процессы.

9. **Наличие комментариев в коде:**
   - Во всех версиях программ присутствует огромное количество комментариев.

10. **Представление результатов работы программы:**
    ![изображение](https://github.com/user-attachments/assets/8c4d4042-1d39-4899-8eb0-a944686a900f)
    


### Критерии на 6–7 баллов

1. **Подробное описание обобщенного алгоритма:**
   - **Субъекты и их отображение в программе**

    1. **Пациенты:**
         * Каждый пациент моделируется отдельным потоком (`patient_thread`).
         * Поток пациента добавляет себя в общую очередь к дежурным врачам (`commonQueue`).
         * После добавления в очередь, поток пациента ожидает обработки (вылечивания) специалистом.
         * После получения лечения пациент завершает свою работу и поток завершается.
    
    2. **Дежурные врачи:**
         * Каждый дежурный врач моделируется отдельным потоком (`duty_doctor_thread`).
         * Поток дежурного врача извлекает пациента из общей очереди (`commonQueue`), если очередь не пуста.
         * После приема пациента, дежурный врач случайным образом определяет, к какому специалисту направить пациента.
         * Направленный пациент добавляется в соответствующую специализированную очередь (`specialistQueue`).
         * Если все пациенты приняты и направлены к специалистам, поток дежурного врача завершает свою работу.
    
    3. **Специалисты:**
         * Каждый специалист (стоматолог, хирург, терапевт) моделируется отдельным потоком (`specialist_thread`).
         * Поток специалиста извлекает пациента из своей специализированной очереди (`specialistQueue`), если очередь не пуста.
         * После лечения пациента, специалист уведомляет пациента о завершении лечения.
         * Если все пациенты обработаны и очереди специалистов пусты, поток специалиста завершает свою работу

2. **Генерация случайных данных:**
   - Выбор специалиста для пациента осуществляется случайно с использованием генератора `std::mt19937`, что обеспечивает разнообразие сценариев обработки пациентов.

3. **Ввод данных из командной строки:**
   - Программы поддерживают ввод параметров через командную строку, позволяя задавать количество пациентов, время обработки и имя файла логов при запуске, также есть опция `--help`, которая объясняет работу с программой в таком режиме.
     ![изображение](https://github.com/user-attachments/assets/1e287084-c0a3-44bd-901b-ada4453b89aa)


4. **Отражение изменений в отчете:**
   - Изменения отражены в соответствующих разделах.

### Критерии на 8 баллов

1. **Вывод результатов в файл с именем из командной строки:**
   - Программы позволяют задавать имя файла для логирования через параметр командной строки `-o <file>`, обеспечивая запись результатов работы в указанный файл.

2. **Ввод данных из конфигурационного файла с использованием ключей:**
   - Программы поддерживают альтернативный вариант ввода параметров из конфигурационного файла через ключ `-f <file>`.

3. **Запись результатов в файл и консоль:**
   - Все логируемые события выводятся одновременно на консоль и записываются в файл,  за это отвечает функция `log_event`.

4. **Наличие нескольких вариантов входных и выходных данных:**
   - Различные входные и выходные файлы содержатся в папке [data](./data)

### Критерии на 9 баллов

1. **Альтернативное решение с использованием других синхропримитивов:**
   - Вообще говоря, уже в первой версии программы использованы условные переменные, что является синхропримитивом, отличным от мьютексов.
   - Вторая версия программы реализована с использованием спинлоков вместо мьютексов, где это возможно, то есть для мьютексов которые не используются в паре с условными переменными. А в остальных случаях мьютексы были заменены на адаптивные мьютексы. Разница заключается в том, что обычные мьютексы во время ожидания отправляют процесс в спящий режим, освобождая ресурсы процессора, в то время как спинлок не уходит в спящий режим и продолжает загружать процессор. При этом на отправление процесса в спящий режим и его восстановление тоже тратится время. Поэтому один из этих видов синхропримитивов может быть лучше, а может быть хуже, в зависимости от условий в которых он применяется. Адаптивный мьютекс это среднее между мьютексом и спинлоком - сначала работает как спинлок, но спустя небольшой промежуток времени переключает процесс в спящий режим, как это делает обычный мьютекс.

2. **Сравнительный анализ поведения программ:**
   - Слева первая версия программы, а справа - вторая.
     ![analysis](https://github.com/user-attachments/assets/ada6484b-c236-4936-aec3-4a73db3ad997)
   - При одинаковых входных данных обе версии программ демонстрируют идентичное поведение, обрабатывая пациентов и направляя их к специалистам с использованием различных механизмов синхронизации. Да в выводе есть отличия, но они не связаны в данном случае с видом синхропримитива, а лишь с порядком, в котором процессор передавал ресурсы процессам. При запуске одной и той же версии программы, можно увидеть такое же поведение.
   - Я провел эксперимент при `N=500, t_d=5, t_s=10`, в котором при нескольких запусках первая программа - на обычных мьютексах, показала время работы в среднем $7.4$ секунды, в то время как вторая программа - на спинлоках и адаптивных мьютексах, показала среднее время работы в $8.5$ секунд, что в $1.15$ раз больше. Я думаю это связано с тем, что спинлоки порой перегружают процессор, используя слишком много его ресурсов для менее важного процесса или процесса, который не так скоро дождется освобождения ресурсов другим процессом, в следствие чего тормозится вся программа. При этом первая версия программы нагружала процессор гораздо меньше согласно диспетчеру задач.

### Критерии на 10 баллов

1. **Разработка дополнительной программы с использованием OpenMP:**
   - Помимо программы на `pthread`, разработана дополнительная версия с использованием OpenMP, удовлетворяя требованиям для получения 10 баллов.

## Заключение

Разработанные многопоточные приложения удовлетворяют всем предъявляемым критериям для получения максимальной оценки. Они корректно моделируют взаимодействие пациентов, дежурных врачей и специалистов, обеспечивают синхронизацию потоков с использованием различных синхропримитивов, поддерживают гибкий ввод параметров и предоставляют информативный вывод как в консоль, так и в файл.


